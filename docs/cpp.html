<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>cpp · asm-dom</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# Table of Contents"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="cpp · asm-dom"/><meta property="og:type" content="website"/><meta property="og:url" content="https://mbasso.github.io/asm-dom/index.html"/><meta property="og:description" content="# Table of Contents"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/asm-dom/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/asm-dom/js/scrollSpy.js"></script><link rel="stylesheet" href="/asm-dom/css/main.css"/><script src="/asm-dom/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/asm-dom/"><h2 class="headerTitle">asm-dom</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/asm-dom/docs/motivation.html" target="_self">Docs</a></li><li class=""><a href="/asm-dom/docs/init.html" target="_self">API</a></li><li class=""><a href="https://github.com/mbasso/asm-dom" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">cpp</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="table-of-contents"></a><a href="#table-of-contents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Table of Contents</h1>
<ul>
<li><a href="#inline-example">Inline Example</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#documentation">Documentation</a>
<ul>
<li><a href="#init">init</a></li>
<li><a href="#h">h</a></li>
<li><a href="#patch">patch</a></li>
<li><a href="#tovnode">toVNode</a></li>
<li><a href="#tohtml">toHTML</a></li>
<li><a href="#deletevnode">deleteVNode</a></li>
</ul></li>
<li><a href="#notes">Notes</a>
<ul>
<li><a href="#memory-management">memory management</a></li>
<li><a href="#boolean-attributes">boolean attributes</a></li>
<li><a href="#string-encoding">string encoding</a></li>
<li><a href="#ref">ref</a></li>
<li><a href="#fragments">fragments</a></li>
</ul></li>
<li><a href="#helpers">Helpers</a>
<ul>
<li><a href="#svg">svg</a></li>
</ul></li>
<li><a href="#server-side-rendering">Server side rendering</a></li>
<li><a href="#webcomponents">WebComponents</a>
<ul>
<li><a href="#using-webcomponents-in-asm-dom">Using WebComponents in asm-dom</a></li>
<li><a href="#using-asm-dom-in-webcomponents">Using asm-dom in WebComponents</a></li>
</ul></li>
<li><a href="#structuring-applications">Structuring applications</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="inline-example"></a><a href="#inline-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inline Example</h2>
<pre><code class="hljs css language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"asm-dom.hpp"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> asmdom;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  Config <span class="hljs-built_in">config</span> = Config();
  init(<span class="hljs-built_in">config</span>);

  VNode* vnode = h(<span class="hljs-string">"div"</span>,
    Data(
      Callbacks {
        {<span class="hljs-string">"onclick"</span>, [](emscripten::val e) -&gt; <span class="hljs-keyword">bool</span> {
          emscripten::val::global(<span class="hljs-string">"console"</span>).call&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-string">"log"</span>, emscripten::val(<span class="hljs-string">"clicked"</span>));
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }}
      }
    ),
    Children {
      h(<span class="hljs-string">"span"</span>,
        Data(
          Attrs {
            {<span class="hljs-string">"style"</span>, <span class="hljs-string">"font-weight: bold"</span>}
          }
        ),
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"This is bold"</span>)
      ),
      h(<span class="hljs-string">" and this is just normal text"</span>, <span class="hljs-literal">true</span>),
      h(<span class="hljs-string">"a"</span>,
        Data(
          Attrs {
            {<span class="hljs-string">"href"</span>, <span class="hljs-string">"/foo"</span>}
          }
        ),
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"I'll take you places!"</span>)
      )
    }
  );

  <span class="hljs-comment">// Patch into empty DOM element – this modifies the DOM as a side effect</span>
  patch(
    emscripten::val::global(<span class="hljs-string">"document"</span>).call&lt;emscripten::val&gt;(
      <span class="hljs-string">"getElementById"</span>,
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"root"</span>)
    ),
    vnode
  );

  VNode* newVnode = h(<span class="hljs-string">"div"</span>,
    Data(
      Callbacks {
        {<span class="hljs-string">"onclick"</span>, [](emscripten::val e) -&gt; <span class="hljs-keyword">bool</span> {
          emscripten::val::global(<span class="hljs-string">"console"</span>).call&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-string">"log"</span>, emscripten::val(<span class="hljs-string">"another click"</span>));
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }}
      }
    ),
    Children {
      h(<span class="hljs-string">"span"</span>,
        Data(
          Attrs {
            {<span class="hljs-string">"style"</span>, <span class="hljs-string">"font-weight: normal; font-style: italic"</span>}
          }
        ),
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"This is now italic type"</span>)
      ),
      h(<span class="hljs-string">" and this is just normal text"</span>, <span class="hljs-literal">true</span>),
      h(<span class="hljs-string">"a"</span>,
        Data(
          Attrs {
            {<span class="hljs-string">"href"</span>, <span class="hljs-string">"/bar"</span>}
          }
        ),
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"I'll take you places!"</span>)
      )
    }
  );

  <span class="hljs-comment">// Second `patch` invocation</span>
  patch(vnode, newVnode); <span class="hljs-comment">// asm-dom efficiently updates the old view to the new state</span>

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="installation"></a><a href="#installation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>If you want to start using asm-dom without configuration you can consider <a href="https://github.com/mbasso/asm-dom-boilerplate">asm-dom-boilerplate</a>, a very simple project that includes all you need, just clone and run it!</p>
<p>Otherwise, here is the guide for the manual installation.</p>
<p>In order to use asm-dom you have to prepare your js and C++ environment.</p>
<p>To do this, as first thing, <strong>before importing your compiled code from C++</strong> (wasm or asmjs) you have to include our js file:</p>
<ul>
<li><p>if you are not using <a href="https://www.npmjs.com/package/asm-dom">npm</a> you can import <a href="https://github.com/mbasso/asm-dom/blob/master/dist/cpp/asm-dom.js">our js file</a> from <a href="https://unpkg.com/asm-dom/dist/cpp/asm-dom.js">unpkg</a></p></li>
<li><p>if you are using <a href="https://www.npmjs.com/package/asm-dom">npm</a> you can install asm-dom:</p>
<pre><code class="hljs css language-bash">npm install --save asm-dom
</code></pre>
<p>and import our js file in this way:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'asm-dom/cpp/'</span>;
</code></pre>
<p>If you are using this library with webpack you also need to install <code>arraybuffer-loader</code>:</p>
<pre><code class="hljs css language-bash">npm install --save-dev arraybuffer-loader
</code></pre>
<p>and add this object to your loaders:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.wasm$/</span>,
  <span class="hljs-attr">loaders</span>: [<span class="hljs-string">'arraybuffer-loader'</span>],
}
</code></pre>
<p>also, if you have some problems with fs, you can add this to your webpack config:</p>
<pre><code class="hljs css language-js">node: {
  <span class="hljs-attr">fs</span>: <span class="hljs-string">'empty'</span>,
},
</code></pre></li>
</ul>
<p>After that, you can build your app using the source code in the <a href="https://github.com/mbasso/asm-dom/tree/master/cpp">cpp</a> folder:</p>
<ul>
<li><code>asm-dom.hpp</code> and <code>asm-dom-server.hpp</code></li>
<li><code>asm-dom.cpp</code> and <code>asm-dom-server.cpp</code> (or <code>asm-dom.a</code> that includes both)</li>
</ul>
<p>and compile it using <a href="http://kripken.github.io/emscripten-site/">emscripten (emcc cli)</a>, <a href="http://webassembly.org/getting-started/developers-guide/">here</a> is the installation guide. A few tips about this step:</p>
<ul>
<li><p>please make sure to use the <code>--bind</code> option during the compilation, otherwise asm-dom will not work.</p></li>
<li><p>emcc has a lot of settings that can optimize the build, we suggest you to see <a href="https://kripken.github.io/emscripten-site/docs/optimizing/Optimizing-Code.html">this</a> page and <a href="(https://github.com/mbasso/asm-dom/tree/master/examples/todomvc%20-%20cpp/package.json)">our configuration</a> in the TODOMVC example.</p></li>
<li><p>we suggest you to compile your app to <code>.bc</code> and then use it to produce a WebAssembly version and an asm.js version that you can use as fallback</p></li>
</ul>
<p>After the compilation you can import your app:</p>
<ul>
<li><p>if you are using webpack, you can see our <a href="(https://github.com/mbasso/asm-dom/tree/master/examples/todomvc%20-%20cpp/src/index.js)">example</a>.</p></li>
<li><p>If you want to use wasm without webpack, you can see <a href="https://gist.github.com/kripken/59c67556dc03bb6d57052fedef1e61ab">this</a> gist.</p></li>
</ul>
<p>If you are using <a href="https://babeljs.io/">babel</a>, please make sure to ignore the compiled files:</p>
<pre><code class="hljs css language-js">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
  <span class="hljs-attr">loaders</span>: [<span class="hljs-string">'babel-loader'</span>],
  <span class="hljs-attr">exclude</span>: [
    <span class="hljs-regexp">/node_modules/</span>,
    /compiled/, <span class="hljs-comment">// folder that contains the compiled code (wasm and asmjs)</span>
    /\.asm\.js$/ <span class="hljs-comment">// ignore all .asm.js files</span>
  ],
}
</code></pre>
<p>You can find a complete example to study in the example folder, <a href="https://github.com/mbasso/asm-dom/tree/master/examples/todomvc%20-%20cpp">here</a> it is.</p>
<p>If you want to use a <a href="https://facebook.github.io/jsx/">JSX</a> like syntax in C++ you can also consider using <a href="https://github.com/mbasso/gccx">gccx</a> before <code>emcc</code>, <a href="https://github.com/mbasso/asm-dom/tree/master/examples/todomvc%20-%20cpx">here</a> you can find the same example with an additional build step.</p>
<h2><a class="anchor" aria-hidden="true" id="examples"></a><a href="#examples" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Examples</h2>
<p>Examples are available in the <a href="https://github.com/mbasso/asm-dom/tree/master/examples">examples folder</a>.</p>
<p>Also, here is the list of third-party examples:</p>
<ul>
<li><a href="https://github.com/kevinaud/asm-dom-OO-counters">asm-dom-OO-counters</a></li>
</ul>
<p>and online Demos:</p>
<ul>
<li><a href="https://mbasso.github.io/asm-dom/examples/todomvc/">TODO MVC</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="documentation"></a><a href="#documentation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Documentation</h2>
<p>All APIs are available in the namespace <code>asmdom</code>. They can be used including using <code>asm-dom.hpp</code>, except <code>toHTML</code> that is defined in <code>asm-dom-server.hpp</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="init"></a><a href="#init" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>init</h3>
<p>The <code>init</code> function has to been called before using <code>asm-dom</code>, in the <code>main</code> function, to prepare its environment. It takes a <code>Config</code> struct defined as follows:</p>
<pre><code class="hljs css language-c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Config</span> {</span> 
  <span class="hljs-keyword">bool</span> clearMemory = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">bool</span> unsafePatch = <span class="hljs-literal">false</span>;
}
</code></pre>
<ul>
<li><code>clearMemory</code>: <code>true</code> by default, set it to <code>false</code> if you want to free memory manually, for more information see <a href="#memory-management">memory management</a>.</li>
<li><code>unsafePatch</code>: <code>false</code> by default, set it to <code>true</code> if you haven't a single <code>patch</code> in your application. This allows you to call patch with an <code>oldVnode</code> that hasn't been used previously.</li>
</ul>
<pre><code class="hljs css language-c++">Config <span class="hljs-built_in">config</span> = Config();
<span class="hljs-built_in">config</span>.unsafePatch = <span class="hljs-literal">true</span>;
init(<span class="hljs-built_in">config</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="h"></a><a href="#h" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>h</h3>
<p>You can create vnodes using <code>h</code> function. <code>h</code> accepts a tag/selector as a <code>std::string</code>, an optional <code>Data</code> struct and an optional <code>std::string</code> or a vector of children. Here is the list of signatures:</p>
<pre><code class="hljs css language-c++"><span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sel)</span></span>;
<span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sel, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; <span class="hljs-built_in">text</span>)</span></span>;
<span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; <span class="hljs-built_in">text</span>, <span class="hljs-literal">true</span>)</span></span>; <span class="hljs-comment">// used to create text nodes</span>
<span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sel, <span class="hljs-keyword">const</span> Data&amp; data)</span></span>;
<span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sel, <span class="hljs-keyword">const</span> Children&amp; children)</span></span>;
<span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sel, VNode* child)</span></span>;
<span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sel, <span class="hljs-keyword">const</span> Data&amp; data, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; <span class="hljs-built_in">text</span>)</span></span>;
<span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sel, <span class="hljs-keyword">const</span> Data&amp; data, <span class="hljs-keyword">const</span> Children&amp; children)</span></span>;
<span class="hljs-function">VNode* <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; sel, <span class="hljs-keyword">const</span> Data&amp; data, VNode* child)</span></span>;
</code></pre>
<p>The data object contains optional attributes, optional props and optional callbacks. Also, attributes can contain 2 special keys:</p>
<ul>
<li><code>ns</code>: the namespace URI to associate with the element</li>
<li><code>key</code>: this property is used to keep pointers to DOM nodes that existed previously to avoid recreating them if it is unnecessary. This is very useful for things like list reordering.</li>
</ul>
<p>And callbacks can contain a special key:</p>
<ul>
<li><code>ref</code>: a callback that provides a way to access DOM nodes, you can learn more about that <a href="#ref">here</a></li>
</ul>
<p>Here is an example, please use our <code>typedef</code> to do that:</p>
<pre><code class="hljs css language-c++"><span class="hljs-comment">// typedef std::function&lt;bool(emscripten::val)&gt; Callback;</span>

<span class="hljs-comment">// typedef std::unordered_map&lt;std::string, std::string&gt; Attrs;</span>
<span class="hljs-comment">// typedef std::unordered_map&lt;std::string, emscripten::val&gt; Props;</span>
<span class="hljs-comment">// typedef std::unordered_map&lt;std::string, Callback&gt; Callbacks;</span>

<span class="hljs-comment">// typedef std::vector&lt;VNode*&gt; Children;</span>

VNode* vnode = h(<span class="hljs-string">"div"</span>,
  Data(
    Attrs {{<span class="hljs-string">"style"</span>, <span class="hljs-string">"color: #000"</span>}}
  ),
  Children {
    h(<span class="hljs-string">"h1"</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">"Headline"</span>)),
    h(<span class="hljs-string">"p"</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">"A paragraph"</span>)),
  }
);

VNode* vnode2 = h(<span class="hljs-string">"div"</span>,
  Data(
    Attrs {
      {<span class="hljs-string">"id"</span>, <span class="hljs-string">"an-id"</span>}, <span class="hljs-comment">// node.setAttribute('id', 'an-id')</span>
      {<span class="hljs-string">"key"</span>, <span class="hljs-string">"foo"</span>},
      {<span class="hljs-string">"class"</span>, <span class="hljs-string">"foo"</span>}, <span class="hljs-comment">// node.setAttribute('class', 'foo')</span>
      {<span class="hljs-string">"data-foo"</span>, <span class="hljs-string">"bar"</span>} <span class="hljs-comment">// a dataset attribute</span>
    },
    Props {
      {<span class="hljs-string">"foo"</span>, emscripten::val(<span class="hljs-number">7</span>)} <span class="hljs-comment">// node.foo = 7</span>
    },
    Callbacks {
      <span class="hljs-comment">// function pointer</span>
      {<span class="hljs-string">"ondblclick"</span>, onDblClick},
      <span class="hljs-comment">// lambda</span>
      {<span class="hljs-string">"onclick"</span>, [](emscripten::val e) -&gt; <span class="hljs-keyword">bool</span> {
        <span class="hljs-comment">// do stuff...</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }},
      <span class="hljs-comment">// ref</span>
      {<span class="hljs-string">"ref"</span>, divRef}
    }
  )
);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="patch"></a><a href="#patch" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>patch</h3>
<p>The <code>patch</code> takes two arguments, the first is a DOM element (you can get it using <a href="https://kripken.github.io/emscripten-site/docs/api_reference/val.h.html">emscripten::val::global</a>) or a vnode representing the current view. The second is a vnode representing the new, updated view. If <code>patch</code> succedeed, the new vnode (the second parameter) is returned.</p>
<p>If a DOM element is passed, <code>newVnode</code> will be turned into a DOM node, and the passed element will be replaced by the created DOM node. If an <code>oldVnode</code> is passed, asm-dom will efficiently modify it to match the description in the new vnode.</p>
<p><strong>If <code>unsafePatch</code> in <code>init</code> is equal to false, any old vnode passed must be the resulting vnode from the previous call to patch. Otherwise, no operation is performed and NULL is returned.</strong></p>
<pre><code class="hljs css language-c++">VNode* oldVnode = h(<span class="hljs-string">"span"</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"old node"</span>));
VNode* newVnode = h(<span class="hljs-string">"span"</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"new node"</span>));

patch(
    emscripten::val::global(<span class="hljs-string">"document"</span>).call&lt;emscripten::val&gt;(<span class="hljs-string">"getElementById"</span>, emscripten::val(<span class="hljs-string">"root"</span>)),
    oldVnode
);
patch(oldVnode, newVnode);

<span class="hljs-comment">// with unsafePatch = false</span>
VNode* vnode = h(<span class="hljs-string">"div"</span>);
patch(oldVnode, vnode); <span class="hljs-comment">// returns NULL, found oldVnode, expected newVnode</span>
</code></pre>
<p>With <code>unsafePatch = true</code> you can implement some interesting mechanisms, for example you can do something like this:</p>
<pre><code class="hljs css language-c++">VNode* oldText = h(<span class="hljs-string">"span"</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"old text"</span>));
VNode* vnode = h(<span class="hljs-string">"div"</span>, Children {
  h(<span class="hljs-string">"span"</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"this is a text"</span>)),
  oldText
});

patch(
    emscripten::val::global(<span class="hljs-string">"document"</span>).call&lt;emscripten::val&gt;(<span class="hljs-string">"getElementById"</span>, emscripten::val(<span class="hljs-string">"root"</span>)),
    vnode
);

VNode* newText = h(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"span"</span>), <span class="hljs-string">"new text"</span>);
<span class="hljs-comment">// patch only the child</span>
patch(oldText, newText);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tovnode"></a><a href="#tovnode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>toVNode</h2>
<p>Converts a DOM node into a virtual node. This is especially good for patching over an pre-existing, server-side generated content.</p>
<pre><code class="hljs css language-c++"><span class="hljs-comment">// supposing that 'root' is a server-side generated div</span>
VNode* vnode = toVNode(
  emscripten::val::global(<span class="hljs-string">"document"</span>).call&lt;emscripten::val&gt;(
    <span class="hljs-string">"getElementById"</span>,
    emscripten::val(<span class="hljs-string">"root"</span>)
  )
);

VNode* newVnode = h(<span class="hljs-string">"div"</span>,
  Data(
    Attrs {
      {<span class="hljs-string">"id"</span>, <span class="hljs-string">"root"</span>}
      {<span class="hljs-string">"style"</span>, <span class="hljs-string">"color: #000"</span>}
    }
  ),
  Children {
    h(<span class="hljs-string">"h1"</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">"Headline"</span>)),
    h(<span class="hljs-string">"p"</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">"A paragraph"</span>)),
  }
);

patch(vnode, newVnode);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tohtml"></a><a href="#tohtml" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>toHTML</h2>
<p>Renders a vnode to HTML string. This is particularly useful if you want to generate HTML on the server.</p>
<pre><code class="hljs css language-c++">VNode* vnode = h(<span class="hljs-string">"div"</span>,
  Data(
    Attrs {
      {<span class="hljs-string">"id"</span>, <span class="hljs-string">"root"</span>}
      {<span class="hljs-string">"style"</span>, <span class="hljs-string">"color: #000"</span>}
    }
  ),
  Children {
    h(<span class="hljs-string">"h1"</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">"Headline"</span>)),
    h(<span class="hljs-string">"p"</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">"A paragraph"</span>)),
  }
);

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> html = toHTML(vnode);
<span class="hljs-comment">// html = &lt;div id="root" style="color: #000"&gt;&lt;h1&gt;Headline&lt;/h1&gt;&lt;p&gt;A paragraph&lt;/p&gt;&lt;/div&gt;;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="deletevnode"></a><a href="#deletevnode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>deleteVNode</h2>
<p>Deletes a vnode and all its children from memory. This is useful if you want to delete an entire tree. If you want to delete a vnode but not its children you can simply use the C++ keyword <code>delete</code>.</p>
<pre><code class="hljs css language-c++">VNode* child1 = h(<span class="hljs-string">"h1"</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">"Headline"</span>));
VNode* child2 = h(<span class="hljs-string">"p"</span>, <span class="hljs-built_in">string</span>(<span class="hljs-string">"A paragraph"</span>));
VNode* vnode = h(<span class="hljs-string">"div"</span>,
  Data(
    Attrs {
      {<span class="hljs-string">"id"</span>, <span class="hljs-string">"root"</span>}
      {<span class="hljs-string">"style"</span>, <span class="hljs-string">"color: #000"</span>}
    }
  ),
  Children {
    child1,
    child2,
  }
);

<span class="hljs-comment">// delete vnode, child1 and child2 from memory</span>
deleteVNode(vnode);

<span class="hljs-comment">// delete vnode but not child1 and child2 from memory</span>
<span class="hljs-comment">// delete vnode;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="notes"></a><a href="#notes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Notes</h2>
<h3><a class="anchor" aria-hidden="true" id="memory-management"></a><a href="#memory-management" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>memory management</h3>
<p>As we said before the <code>h</code> returns a pointer to a VNode, this means that the memory have to be deleted manually. By default asm-dom automatically delete the old vnode from memory when <code>patch</code> (or <code>toHTML</code>) is called. However, if you want to create a vnode that is not patched, or if you want to manually manage this aspect (setting <code>clearMemory = false</code> in the <code>Config</code> object to pass to the <code>init</code> function), you have to delete it manually.</p>
<pre><code class="hljs css language-c++">VNode* vnode1 = h(<span class="hljs-string">"div"</span>);
VNode* vnode2 = h(<span class="hljs-string">"div"</span>, Children {
  h(<span class="hljs-string">"span"</span>)
});
patch(vnode1, vnode2); <span class="hljs-comment">// vnode1 automatically deleted</span>

VNode* child1 = h(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"span"</span>), <span class="hljs-string">"child 1"</span>);
VNode* child2 = h(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"span"</span>), <span class="hljs-string">"child 2"</span>);
VNode* vnode = h(<span class="hljs-string">"span"</span>, Children {
  child1,
  child2,
});
deleteVNode(vnode); <span class="hljs-comment">// manually delete vnode, child1 and child2 from memory</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="boolean-attributes"></a><a href="#boolean-attributes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>boolean attributes</h3>
<p>If you want to set a boolean attribute, like <code>readonly</code>, you can just pass true or false as string, asm-dom will handle it for you:</p>
<pre><code class="hljs css language-c++">VNode* vnode = h(<span class="hljs-string">"input"</span>,
  Data(
    Attrs {
      {<span class="hljs-string">"type"</span>, <span class="hljs-string">"text"</span>}
      {<span class="hljs-string">"readonly"</span>, <span class="hljs-string">"true"</span>}
      <span class="hljs-comment">// or {"readonly", "false"}</span>
    },
  )
);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="string-encoding"></a><a href="#string-encoding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>string encoding</h3>
<p>asm-dom renders attributes in UTF-8 (they are std::string) and props in UTF-16 (they are <a href="https://kripken.github.io/emscripten-site/docs/api_reference/val.h.html">emscripten::val</a>).
If you want to take a string from javascript, from an input for example, you have to know that this string is encoded in UTF-16 and you can save it in a <code>std::wstring</code> variable, so, you have to pay attention to the encoding. In the <a href="https://github.com/mbasso/asm-dom/tree/master/examples/todomvc%20-%20cpp">TODOMVC example</a> you can see how we have dealed with that. We have created <a href="https://github.com/mbasso/asm-dom/blob/cpp-api/examples/todomvc%20-%20cpp/src/helpers.cpp">2 helpers</a> that are used when we take values from events (event.target.value) and put values into props. Here is an example:</p>
<pre><code class="hljs css language-c++"><span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">wstring</span> <span class="hljs-title">utf8_to_wstring</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str)</span> </span>{
  <span class="hljs-built_in">std</span>::wstring_convert&lt;<span class="hljs-built_in">std</span>::codecvt_utf8&lt;<span class="hljs-keyword">wchar_t</span>&gt;&gt; converter;
  <span class="hljs-keyword">return</span> converter.from_bytes(str);
};

<span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">wstring_to_utf8</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span>&amp; str)</span> </span>{
  <span class="hljs-built_in">std</span>::wstring_convert&lt;<span class="hljs-built_in">std</span>::codecvt_utf8&lt;<span class="hljs-keyword">wchar_t</span>&gt;&gt; converter;
  <span class="hljs-keyword">return</span> converter.to_bytes(str);
};

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> KEY_ENTER = <span class="hljs-number">13</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// some code here...</span>

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> val = getInputValue();

  VNode* vnode = h(<span class="hljs-string">"input"</span>,
    Data(
      Attrs {
        <span class="hljs-comment">// UTF-8 encoding, no stuff needed</span>
        {<span class="hljs-string">"type"</span>, <span class="hljs-string">"text"</span>}
        <span class="hljs-comment">// UTF-8 encoding, u8 needed for accented characters</span>
        {<span class="hljs-string">"class"</span>, <span class="hljs-string">u8"ehilà"</span>}
      },
      Props {
        <span class="hljs-comment">// setting a prop: UTF-8 to UTF-16</span>
        {<span class="hljs-string">"value"</span>, emscripten::val(utf8_to_wstring(val))}
        {<span class="hljs-string">"anotherProp"</span>, emscripten::val(<span class="hljs-string">L"This is UTF-16"</span>)}
      },
      Callbacks {
        {<span class="hljs-string">"onkeydown"</span>, [handler](emscripten::val e) -&gt; <span class="hljs-keyword">bool</span> {
          <span class="hljs-comment">// get value from event: UTF-16 to UTF-8</span>
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> value = wstring_to_utf8(e[<span class="hljs-string">"target"</span>][<span class="hljs-string">"value"</span>].as&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span>&gt;());
          <span class="hljs-keyword">if</span> (e[<span class="hljs-string">"keyCode"</span>].as&lt;<span class="hljs-keyword">int</span>&gt;() == KEY_ENTER &amp;&amp; !value.empty()) {
            <span class="hljs-comment">// do stuff...</span>
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }}
      }
    )
  );

  <span class="hljs-comment">// some code here...</span>
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ref"></a><a href="#ref" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ref</h3>
<p>If you want to access direclty DOM nodes created by asm-dom, for example to managing focus, text selection, or integrating with third-party DOM libraries, you can use <code>refs callbacks</code>. <code>ref</code> is a special callback that takes the DOM node as param and can return <code>true</code> or <code>false</code> unconditionally, this is just for semplicity, to mantain the same signatures of other events.
<code>ref</code> is called after that the DOM node is mounted, if the ref callback changes or after that the DOM node is removed from the DOM tree, in this case the param is evaluated <code>emscripten::val::null</code>.
Here is an example of the first and the last case:</p>
<pre><code class="hljs css language-c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">refCallback</span><span class="hljs-params">(emscripten::val node)</span> </span>{
  <span class="hljs-comment">// check if node === null</span>
  <span class="hljs-keyword">if</span> (node.strictlyEquals(emscripten::val::null())) {
    <span class="hljs-comment">// node unmounted</span>
    <span class="hljs-comment">// do nothing</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// node mounted</span>
    <span class="hljs-comment">// focus input</span>
    node.call&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-string">"focus"</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  Config <span class="hljs-built_in">config</span> = Config();
  init(<span class="hljs-built_in">config</span>);

  VNode* vnode1 = h(<span class="hljs-string">"div"</span>,
    h(<span class="hljs-string">"input"</span>,
      Data(
        Callbacks {
          {<span class="hljs-string">"ref"</span>, refCallback}
        }
      )
    )
  );

  patch(
    emscripten::val::global(<span class="hljs-string">"document"</span>).call&lt;emscripten::val&gt;(
      <span class="hljs-string">"getElementById"</span>,
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"root"</span>)
    ),
    vnode1
  );

  VNode* vnode2 = h(<span class="hljs-string">"div"</span>);
  patch(vnode1, vnode2);

  deleteVNode(vnode2);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>As we said before <code>ref callback</code> is also invoked if it changes, in the following example asm-dom will call <code>refCallback</code> after that the DOM node is mounted and then <code>anotherRefCallback</code> after the update:</p>
<pre><code class="hljs css language-c++">VNode* vnode1 = h(<span class="hljs-string">"div"</span>,
  h(<span class="hljs-string">"input"</span>,
    Data(
      Callbacks {
        {<span class="hljs-string">"ref"</span>, refCallback}
      }
    )
  )
);

patch(
  emscripten::val::global(<span class="hljs-string">"document"</span>).call&lt;emscripten::val&gt;(
    <span class="hljs-string">"getElementById"</span>,
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"root"</span>)
  ),
  vnode1
);

VNode* vnode2 = h(<span class="hljs-string">"div"</span>,
  h(<span class="hljs-string">"input"</span>,
    Data(
      Callbacks {
        {<span class="hljs-string">"ref"</span>, anotherRefCallback}
      }
    )
  )
);

patch(vnode1, vnode2);
</code></pre>
<p>Please note that if you want to use a lambda as a ref asm-dom will call it on every update, so, you probably want to avoid something like this:</p>
<pre><code class="hljs css language-c++">VNode* vnode1 = h(<span class="hljs-string">"div"</span>,
  h(<span class="hljs-string">"input"</span>,
    Data(
      Callbacks {
        {<span class="hljs-string">"ref"</span>, [&amp;](emscripten::val node) -&gt; <span class="hljs-keyword">bool</span> {
          <span class="hljs-keyword">if</span> (!node.strictlyEquals(emscripten::val::null())) {
            <span class="hljs-comment">// node mounted</span>
            <span class="hljs-comment">// focus input</span>
            node.call&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-string">"focus"</span>);
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }}
      }
    )
  )
);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="fragments"></a><a href="#fragments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fragments</h3>
<p>If you want to group a list of children without adding extra nodes to the DOM or you want to use <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment">DocumentFragments</a> to improve the performance of your app, you can do that creating a <code>VNode</code> with an empty selector:</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// without fragments if you want to return 3 div</span>
<span class="hljs-comment">// you have to add a parent node that is inserted into the DOM tree</span>
<span class="hljs-comment">/* asmdom::VNode* vnode = (
    h("div",
        Children {
            h("div", std::string("Child 1")),
            h("div", std::string("Child 2")),
            h("div", std::string("Child 3"))
        }
    )
); */</span>

<span class="hljs-comment">// with fragments you can just add them without additional nodes</span>
<span class="hljs-attr">asmdom</span>::VNode* vnode = (
    h(<span class="hljs-string">""</span>,
        Children {
            h(<span class="hljs-string">"div"</span>, <span class="hljs-attr">std</span>::string(<span class="hljs-string">"Child 1"</span>)),
            h(<span class="hljs-string">"div"</span>, <span class="hljs-attr">std</span>::string(<span class="hljs-string">"Child 2"</span>)),
            h(<span class="hljs-string">"div"</span>, <span class="hljs-attr">std</span>::string(<span class="hljs-string">"Child 3"</span>))
        }
    )
);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="helpers"></a><a href="#helpers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Helpers</h2>
<h3><a class="anchor" aria-hidden="true" id="svg"></a><a href="#svg" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>svg</h3>
<p>SVG just works when using the <code>h</code> function for creating virtual nodes. SVG elements are automatically created with the appropriate namespaces.</p>
<pre><code class="hljs css language-c++">VNode* vnode = h(<span class="hljs-string">"div"</span>, Children {
  h(<span class="hljs-string">"svg"</span>,
    Data(
      Attrs {
        {<span class="hljs-string">"width"</span>, <span class="hljs-string">"100"</span>},
        {<span class="hljs-string">"height"</span>, <span class="hljs-string">"100"</span>}
      }
    ),
    Children {
      h(<span class="hljs-string">"circle"</span>,
        Data(
          Attrs {
            {
              {<span class="hljs-string">"cx"</span>, <span class="hljs-string">"50"</span>},
              {<span class="hljs-string">"cy"</span>, <span class="hljs-string">"50"</span>},
              {<span class="hljs-string">"r"</span>, <span class="hljs-string">"40"</span>},
              {<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"green"</span>},
              {<span class="hljs-string">"stroke-width"</span>, <span class="hljs-string">"4"</span>},
              {<span class="hljs-string">"fill"</span>, <span class="hljs-string">"yellow"</span>}
            }
          }
        )
      )
    }
  )
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="server-side-rendering"></a><a href="#server-side-rendering" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Server side rendering</h2>
<p>If you are interested in server side rendering, you can do that with asm-dom in 2 simple steps:</p>
<ul>
<li>You can use <code>toHTML</code> to generate HTML on the server and send it to the client for faster page loads and to allow search engines to crawl your pages for SEO purposes.</li>
<li>After that you can call <code>toVNode</code> on the node that you have server-rendered and patch it with a vnode created on the client. In this way asm-dom will preserve it and only attach event handlers, providing a fantastic first-load experience.</li>
</ul>
<p>Here is an example:</p>
<pre><code class="hljs css language-c++"><span class="hljs-comment">// a function that returns the view, used on client and server</span>
<span class="hljs-function">VNode* <span class="hljs-title">view</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> (
    h(<span class="hljs-string">"div"</span>,
      Data(
        Attrs {
          {<span class="hljs-string">"id"</span>, <span class="hljs-string">"root"</span>}
        }
      ),
      Children {
        h(<span class="hljs-string">"h1"</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"Title"</span>)),
        h(<span class="hljs-string">"button"</span>,
          Data(
            Attrs {
              {<span class="hljs-string">"class"</span>, <span class="hljs-string">"btn"</span>}
            },
            Callbacks {
              {<span class="hljs-string">"onclick"</span>, onButtonClick}
            }
          ),
          <span class="hljs-string">"Click Me!"</span>
        )
      }
    )
  );
}

<span class="hljs-comment">// on the server</span>
VNode* vnode = view();
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> appString = toHTML(vnode);
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> html = (
  <span class="hljs-string">"&lt;!DOCTYPE html&gt;"</span>
  <span class="hljs-string">"&lt;html&gt;"</span>
    <span class="hljs-string">"&lt;head&gt;"</span>
      <span class="hljs-string">"&lt;title&gt;My Awesome App&lt;/title&gt;"</span>
      <span class="hljs-string">"&lt;link rel=\"stylesheet\" href=\"/index.css\" /&gt;"</span>
    <span class="hljs-string">"&lt;/head&gt;"</span>
    
    <span class="hljs-string">"&lt;body&gt;"</span>
      + appString +
    <span class="hljs-string">"&lt;/body&gt;"</span>
    
    <span class="hljs-string">"&lt;script src=\"/bundle.js\"&gt;&lt;/script&gt;"</span>
  <span class="hljs-string">"&lt;/html&gt;"</span>
);

<span class="hljs-comment">// on the client</span>
VNode* oldVNode = toVNode(
  emscripten::val::global(<span class="hljs-string">"document"</span>).call&lt;emscripten::val&gt;(<span class="hljs-string">"getElementById"</span>, emscripten::val(<span class="hljs-string">"root"</span>))
);
VNode* vnode = view();
patch(oldVNode, vnode); <span class="hljs-comment">// attach event handlers</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="webcomponents"></a><a href="#webcomponents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>WebComponents</h2>
<p>Virtual DOM and WebComponents represent different technologies. Virtual DOM provides a declarative way to write the UI and keep it sync with the data, while WebComponents provide an encapsulation for reusable components. There are no limitation to use them together, you can use asm-dom with WebComponents or use asm-dom inside WebComponents.</p>
<h3><a class="anchor" aria-hidden="true" id="using-webcomponents-in-asm-dom"></a><a href="#using-webcomponents-in-asm-dom" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using WebComponents in asm-dom</h3>
<p>With asm-dom you can just use WebComponents as any other element:</p>
<pre><code class="hljs css language-c++"><span class="hljs-comment">// customElements.define('my-tabs', MyTabs);</span>

VNode* vnode = h(<span class="hljs-string">"my-tabs"</span>,
  Data(
    Attrs {
      {<span class="hljs-string">"class"</span>, <span class="hljs-string">"css-class"</span>},
      {<span class="hljs-string">"attr"</span>, <span class="hljs-string">"an attribute"</span>}
    },
    Props {
      {<span class="hljs-string">"prop"</span>, <span class="hljs-string">"a prop"</span>}
    },
    Callbacks {
      {<span class="hljs-string">"tab-select"</span>, onTabSelect}
    }
  ),
  Children {
    h(<span class="hljs-string">"p"</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">"I'm a child!"</span>))
  }
);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="using-asm-dom-in-webcomponents"></a><a href="#using-asm-dom-in-webcomponents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using asm-dom in WebComponents</h3>
<p>At the moment creating WebComponents from C++ is not so easy, you problably need to mix some C++ and Javascript code, maybe with <a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#calling-javascript-from-c-c"><code>emscripten_run_script</code></a>, <a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#calling-javascript-from-c-c"><code>EM_ASM</code></a> or <a href="http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html"><code>Embind</code></a>.
Please, to make asm-dom work, make sure to enable the usage of <a href="#patch"><code>patch</code></a> in multiple points of your app with <code>unsafePatch = true</code> in the <a href="#init"><code>init</code></a> function.</p>
<h2><a class="anchor" aria-hidden="true" id="structuring-applications"></a><a href="#structuring-applications" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Structuring applications</h2>
<p>asm-dom is a low-level virtual DOM library. It is unopinionated with regards to how you should structure your application.</p>
<p>You can take a look to <a href="https://github.com/snabbdom/snabbdom#structuring-applications">this</a> list in snabbdom repository, a js virtual DOM that inspire this library. Snabbdom has javascript APIs but you can still take inspiration from it and translate structures in C++.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/asm-dom/" class="nav-home"></a><div><h5>Docs</h5><a href="/asm-dom/docs/motivation.html">Introduction</a><a href="/asm-dom/docs/memory-management.html">Guides</a><a href="/asm-dom/docs/init.html">API Reference</a></div><div><h5>Community</h5><a href="http://stackoverflow.com/questions/tagged/asm-dom" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://gitter.im/mbasso/asm-dom">Chat on Gitter</a><a href="https://twitter.com/teo_basso"><img alt="Follow teo_basso on Twitter" src="https://img.shields.io/twitter/follow/teo_basso.svg?label=Follow+teo_basso&amp;style=social"/></a></div><div><h5>More</h5><a href="https://github.com/mbasso/asm-dom">GitHub</a><a href="https://github.com/mbasso/asm-dom/issues">Issues</a><a class="github-button" href="https://github.com/mbasso/asm-dom" data-icon="octicon-star" data-count-href="/mbasso/asm-dom/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section></footer></div></body></html>